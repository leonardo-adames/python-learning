# BootCamp Python 3.14 - Sesión 2

## 2.2.1 - Funciones en Python

### ¿QUÉ SON?

En Python, los `parámetros` son las `variables` definidas en la firma de una función (`marcadores de posición`), mientras que los `argumentos` son los `valores` reales pasados al llamarla. La `sintaxis` básica para definir una función con parámetros en Python es la siguiente:

```PYTHON
def nombre_de_la_funcion(parametro1, parametro2, ...):
    # bloque de código de la función que utiliza los parámetros
```
>parametro1, parametro2,… son los parámetros de la funcion

<BR>

**Los argumentos** se asignan a los parámetros por `posición`, por `nombre  (palabras clave)`, o mediante `valores predeterminados`:

<BR>

**Parámetros Posicionales:** Se asignan en el orden exacto de definición:

```python

def saludar(nombre, mensaje): # parámetros
    print(f"{mensaje}, {nombre}")

saludar("Ana", "Hola") # argumentos

```
<BR>

**Argumentos de Palabras Clave (Keyword):** Se especifican por nombre, permitiendo cambiar el orden:

```python

def saludar(nombre, mensaje): # parámetros
    print(f"{mensaje}, {nombre}")

saludar(mensaje="Hola", nombre="Ana") # argumentos

```
<BR>

**Valores Predeterminados:** Se asignan valores por defecto en la definición:

```python

def saludar(nombre="Mundo"):
    print(f"Hola, {nombre}")
saludar() # Imprime: Hola, Mundo

```
---
<br>

**Argumentos Arbitrarios (`*args` y `**kwargs`):** Permiten recibir un número variable de argumentos. A veces, cuando creas una `función`, no sabes cuántos datos te van a enviar. Imagina que eres un chef haciendo una pizza. Sabes que lleva masa y salsa, pero no sabes cuántos ingredientes extra pedirá el cliente.



A. *args (`La lista de ingredientes`)**
El asterisco * es mágico. Le dice a Python: "Toma todos los argumentos sobrantes que no tengan nombre y mételos en una tupla". Por convención le llamamos args, pero podrías llamarlo *ingredientes.

**Ejemplo:**

```python
def hacer_pizza(tamaño, *ingredientes):
    print(f"Preparando pizza {tamaño} con:")
    # Como 'ingredientes' es una tupla, podemos recorrerla
    for ingrediente in ingredientes:
        print(f"- {ingrediente}")

# Llamada con 1 extra
hacer_pizza("Grande", "Queso")
print("---")
# Llamada con 3 extras
hacer_pizza("Mediana", "Pepperoni", "Champiñones", "Pimientos")
```
>Lo que pasa bajo el capó: Python empaqueta "`Pepperoni`", "`Champiñones`", "`Pimientos"` en una tupla: `("Pepperoni", "Champiñones", "Pimientos")`.
---
<br>

B **kwargs (Los detalles del pedido)**

El doble asterisco ** es para argumentos con nombre (KeyWord ARGuments). Python los empaqueta en un diccionario.

**Ejemplo:**

```python

def perfil_usuario(nombre, **datos_extra):
    print(f"Usuario: {nombre}")
    print("Información adicional:", datos_extra)

# Llamada normal
perfil_usuario("Ana")

# Llamada con datos variables
perfil_usuario("Carlos", edad=25, ciudad="Madrid", ocupacion="Estudiante")
```
>Lo que pasa bajo el capó: datos_extra se convierte en: `{'edad': 25, 'ciudad': 'Madrid', 'ocupacion': 'Estudiante'}`.

**Uso de `*` y `**` al llamar una función**

Cuando tenemos una lista o diccionario y queremos pasar sus elementos como argumentos a una función, podemos usar `*` y `**` respectivamente:

```python
def sumar(a, b, c):
    return a + b + c

valores = [1, 2, 3]
print(sumar(*valores))  # Resultado: 6
```
>Aquí:<br>
>- valores es una lista que contiene `[1, 2, 3]`<br>
>- Al llamar sumar(`*valores`), los elementos de la lista se desempaquetan y se pasan como argumentos a la función sumar
>- Es decir, es equivalente a llamar sumar`(1, 2, 3)`.

<br>

El operador `**` se utiliza de manera similar, pero para desempaquetar los elementos de un diccionario y pasarlos como argumentos a una función.<br>
En este caso, las claves del diccionario se convierten en nombres de parámetros y los valores del diccionario se asignan a esos parámetros.

```python
diccionario = {"a": 1, "b": 2, "c": 3}
print(sumar(**diccionario))  # Resultado: 6
```

> Aquí:<br>
>- diccionario es un diccionario que contiene {"a": 1, "b": 2, "c": 3}<br>
>- Al llamar sumar(**diccionario), los elementos del diccionario se desempaquetan y se pasan como argumentos a la función sumar,<br>
>- La clave "a" se asigna al parámetro a, la clave "b" se asigna a b y la clave "c" se asigna a c<br>
>- Es decir, es equivalente a llamar sumar(a=1, b=2, c=3)

---
<br>

**Paso por valor o por referencia**

En `Python`, el paso de argumentos a funciones se realiza siempre por valor (es decir, que la función siempre recibe una copia del argumento).

Pero el comportamiento será diferente si lo que pasamos es un tipo básico o una referencia.

>- En un tipo básico, la función invocada no podrá modificar el argumento que recibe
En un tipo referencia, sí podrá modificar el argumento que recibe.

Vamos a verlo con un ejemplo. Primero veamos el comportamiento cuando pasamos un tipo básico. Por ejemplo, pasamos número entero `(int)` a la función `modificar_numero()`.

Dentro de la función, multiplicamos el número por 2. Esta modificación no afecta al número original fuera de la función.

```python
# Ejemplo con un tipo básico (int)
def modificar_numero(numero):
    numero = numero * 2

numero_original = 5
modificar_numero(numero_original)
print("Número original después de llamar a la función:", numero_original)  # Resultado: 5.
```
Ahora veamos lo que pasa con un tipo referencia, por ejemplo una lista que pasamos como referencia a la función `modificar_lista()`.

Dentro de la función, añadimos el número 4 a la lista. La modificación realizada dentro de la función se refleja en la lista original fuera de la función.

```python
# Ejemplo con una referencia (lista)
def modificar_lista(lista):
    lista.append(4)

lista_original = [1, 2, 3]
modificar_lista(lista_original)
print("Lista original después de llamar a la función:", lista_original)  # Resultado: [1, 2, 3, 4]
```




