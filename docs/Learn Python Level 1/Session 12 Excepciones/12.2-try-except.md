# Learning Python Level 1 - Seccion 12- Las Excepciones

## 12.2 `Try` & `Except`

### Trabajando con el bloque `Try`& `Except`

El bloque `try-except` en Python se utiliza para el manejo de excepciones, permitiendo gestionar errores de tiempo de ejecución sin detener el programa. El código que puede fallar se coloca en el bloque `try`, mientras que el bloque `except` captura y gestiona el error específico.

Dentro del bloque `try - except` también se trabaja conla sentencia `else`. La sentencia `else` sirve para ejecutar código que se ejecuta solo si no ocurrió ninguna excepción en el bloque `try`.

Dentro del bloque `try - except` también se trabaja conla sentencia `finally`. La sentencia `finaly` sirve para ejecutar código que debe ejecutarse siempre, independientemente de si ocurrió una excepción o no.

### Sintaxis

```python
try:
    'Código que podría causar una excepción'
except TipoDeExcepcion:
    'Código que se ejecuta si ocurre la excepción'
else:
    'Código que se ejecuta solo si no ocurrió ninguna excepción'
finally:
    'Código que se ejecuta siempre'
```

---
## ¿Cómo se manejan?

**`try:`** El código que podría causar una excepción se coloca aquí.

**`except:`** Si ocurre una excepción en el try, el código en el except correspondiente se ejecuta. Puedes especificar el tipo de   excepción (ej. except ZeroDivisionError:) o capturar varias.

**`finally:`** El código en el bloque finally se ejecuta siempre, independientemente de si ocurrió una excepción o no.

### Ejemplo:

```python
try:
    resultado = 10 / 0  # Esto causa un ZeroDivisionError
except ZeroDivisionError:
    print("Error: No se puede dividir por cero.")
finally:
    print("Ejecución finalizada.")

```
---
## Beneficios:

- **Prevención de fallos:** Evita que la aplicación se detenga abruptamente.

- **Código robusto:** Maneja errores específicos y proporciona mensajes personalizados.

- **Limpieza:** El bloque finally asegura la liberación de recursos. 

Es recomendable ser específico con el tipo de excepción en el bloque except para no ocultar errores inesperados.
Es recomendable ser específico con el tipo de excepción en el bloque except para no ocultar errores inesperados.

## Lanzamiento de Excepciones con `try - except`

Antes de empezar, lo primero que debemos conocer son los tipos de errores o excepciones que se pueden producir en python  que se pueden manejar con las sentencia  `try - except`, aquí algunos ejemplos más comunes:

- **`SyntaxError:`** Error de sintaxis en el código.

- **`NameError:`** Usar una variable que no está definida. 

- **`ValueError:`** Valor incorrecto para una operación.

- **`IndentationError:`** Error de indentación en el código.

- **`TypeError:`** Usar un tipo de dato incorrecto en una operación.

- **`IndexError:`** Acceder a un índice fuera de rango en una lista. 

- **`KeyError:`** Acceder a una clave que no existe en un diccionario.

- **`AttributeError:`** Atributo no encontrado en un objeto.

- **`ZeroDivisionError:`** Dividir por cero.

- **`FileNotFoundError:`** Intentar abrir un archivo que no existe.

<br>

## Errores & Excepciones

### `SyntaxError`: Error de sintaxis en el código.

Los errores de sintaxis, también conocidos como errores de análisis, son quizás el tipo de queja más común que recibes mientras todavía estás aprendiendo Python:

**EJEMPLO 1:**

**Malo**

```python
a =10
b 8

print(a + b)

SyntaxError: invalid syntax
```
**bueno**

```python
a =10
b = 8

print(a + b)

# Output: 18
```
---
**EJEMPLO 2:**

**Malo**

```python
while True print('Hello world')
  File "<stdin>", line 1
    while True print('Hello world')
               ^^^^^
SyntaxError: invalid syntax
```

**Bueno**

```python
while True:
    print('Hello world')

#Output: Hello world (se ejecuta infinitamente)
```

El analizador repite la línea incorrecta y muestra pequeñas flechas `>>>` que señalan el lugar donde se detectó el error.<br>
Tenga en cuenta que este no siempre es el lugar que debe corregirse. En el ejemplo, el error se detecta en la función `print()`, ya que faltan dos puntos (`':'`) justo antes.

El nombre del archivo ( `<stdin>` en nuestro ejemplo) y el número de línea se imprimen para que sepa dónde buscar en caso de que la entrada provenga de un archivo.

---
### `NameError`: Nombre no definido

El `NameError` se produce cuando intentas usar una variable o función que no ha sido definida.

**EJEMPLO 1:**

**Malo**

```python
'2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    '2' + 2
    ~~~~^~~
```
**Bueno**

```python
int('2') + 2
# Output: 4
```
---
### `ValueError`: Valor incorrecto para una operación

El `ValueError` se produce cuando intentas convertir un valor a un tipo de dato incompatible.

**EJEMPLO 1:**

**Malo**

```python
int('hello')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    int('hello')
    ~~~^^^^^^^^^
ValueError: invalid literal for int() with base 10: 'hello'
```

**Bueno**

```python
int('123')
# Output: 123
```

### `IndentationError`: Error de indentación en el código.

El `IndentationError` se produce cuando el código no está indentado correctamente.

**EJEMPLO 1:**

**Malo**

```python
if True:
print('Hello')
  File "<stdin>", line 2
    print('Hello')
    ^^^^^^^^^^^^
IndentationError: expected an indented block after 'if' statement on line 1
```

**Bueno**

```python
if True:
    print('Hello')
# Output: Hello
```

### `TypeError`: Tipo de dato incorrecto para una operación.

El `TypeError` se produce cuando intentas realizar una operación con un tipo de dato incompatible.

**EJEMPLO 1:**

**Malo**

```python
'2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    '2' + 2
    ~~~~^~~
TypeError: can only concatenate str (not "int") to str
```

**Bueno**

```python
int('2') + 2
# Output: 4
```

### `IndexError`: Índice fuera de rango.

El `IndexError` se produce cuando intentas acceder a un índice que no existe en una lista o cadena.

**EJEMPLO 1:**

**Malo**

```python
my_list = [1, 2, 3]
print(my_list[3])
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
    print(my_list[3])
          ~~~~~~~^^^
IndexError: list index out of range
```

**Bueno**

```python
my_list = [1, 2, 3]
print(my_list[2])
# Output: 3
```

### `KeyError`: Clave no encontrada en un diccionario.

El `KeyError` se produce cuando intentas acceder a una clave que no existe en un diccionario.

**EJEMPLO 1:**

**Malo**

```python
my_dict = {'a': 1, 'b': 2}
print(my_dict['c'])
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
    print(my_dict['c'])
          ~~~~~~~~^^^
KeyError: 'c'
```

**Bueno**

```python
my_dict = {'a': 1, 'b': 2}
print(my_dict.get('c'))
# Output: None
```

### `AttributeError`: Atributo no encontrado en un objeto.

El `AttributeError` se produce cuando intentas acceder a un atributo que no existe en un objeto.

**EJEMPLO 1:**

**Malo**

```python
my_list = [1, 2, 3]
print(my_list.length)
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
    print(my_list.length)
          ^^^^^^^^^^^^^
AttributeError: 'list' object has no attribute 'length'
```

**Bueno**

```python
my_list = [1, 2, 3]
print(len(my_list))
# Output: 3
```
### `ZeroDivisionError`: División por cero.

El `ZeroDivisionError` se produce cuando intentas dividir un número por cero.

**EJEMPLO 1:**

**Malo**

```python
10 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    10 / 0
    ~~^~~
ZeroDivisionError: division by zero
```

**Bueno**

```python
10 / 2
# Output: 5.0
```
### `FileNotFoundError:` Archivo no encontrado.

El `FileNotFoundError` se produce cuando intentas abrir un archivo que no existe.

**EJEMPLO 1:**

**Malo**

```python
with open('nonexistent_file.txt', 'r') as f:
    content = f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    with open('nonexistent_file.txt', 'r') as f:
         ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: 'nonexistent_file.txt'
```

**Bueno**

```python
try:
    with open('nonexistent_file.txt', 'r') as f:
        content = f.read()
except FileNotFoundError:
    print('File not found')
# Output: File not found
```
<br>

Es posible escribir programas que gestionen excepciones seleccionadas. Observe el siguiente ejemplo, que solicita al usuario una entrada hasta que se introduzca un entero válido, pero permite al usuario interrumpir el programa (usando `Control- C` o cualquier método compatible con el sistema operativo);<br>
tenga en cuenta que una interrupción generada por el usuario se indica lanzando la [KeyboardInterrupt](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt) excepción.

```python
while True:
    try:
        x = int(input("Please enter a number: "))
        break
    except ValueError:
        print("Oops!  That was no valid number.  Try again...")
# Output: Please enter a number: 
```

La declaración `try` funciona de la siguiente manera:

Primero, se ejecuta la cláusula `try` (las declaraciones entre las palabras clave `try`y )`.except`

Si no ocurre ninguna excepción, se omite la sentencia `try` `except` y se finaliza la ejecución de la instrucción.

Si se produce una excepción durante la ejecución de la sentencia `try`, se omite el resto de la misma. 

Si su tipo coincide con la excepción nombrada tras la sentencia `except`, se ejecuta la cláusula `except` y la ejecución continúa después del bloque `try/except`.

Si ocurre una excepción que no coincide con la excepción nombrada en la cláusula `except` , se pasa a instrucciones externas `try`; 
si no se encuentra ningún controlador, es una excepción no controlada y la ejecución se detiene con un mensaje de error.

Una trysentencia puede tener más de una cláusula except para especificar controladores para diferentes excepciones. Se ejecutará como máximo un controlador. 
Los controladores solo gestionan las excepciones que ocurren en la cláusula `try` correspondiente , no en otros controladores de la misma trysentencia. 
Una cláusula `except` puede nombrar varias excepciones como una tupla entre paréntesis, por ejemplo:

```python
except (RuntimeError, TypeError, NameError):
    pass
```
---
Una clase en una exceptcláusula coincide con las excepciones que son instancias de la propia clase o de una de sus clases derivadas (pero no al revés;<br>
una cláusula except que enumera una clase derivada no coincide con las instancias de sus clases base). Por ejemplo, el siguiente código imprimirá `B, C, D` en ese orden:

```python
class B(Exception):
    pass

class C(B):
    pass

class D(C):
    pass

for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D")
    except C:
        print("C")
    except B:
        print("B")
```

Tenga en cuenta que si las cláusulas `except` se invirtieran (con `first`), se habría impreso `B, B, B` — se activa la primera cláusula `except` coincidente `except B`

Cuando se produce una excepción, puede tener valores asociados, también conocidos como argumentos de la excepción . La presencia y los tipos de argumentos dependen del tipo de excepción.

La cláusula `except` puede especificar una variable después del nombre de la excepción. Esta variable está vinculada a la instancia de la excepción, 
que normalmente tiene un args atributo que almacena los argumentos. Para mayor comodidad, 
los tipos de excepción predefinidos definen` __str__()` la impresión de todos los argumentos sin acceder explícitamente a `.args`.

```python
try:
    raise Exception('spam', 'eggs')
except Exception as inst:
    print(type(inst))    # the exception type
    print(inst.args)     # arguments stored in .args
    print(inst)          # __str__ allows args to be printed directly,
                         # but may be overridden in exception subclasses
    x, y = inst.args     # unpack args
    print('x =', x)
    print('y =', y)
```


