# Learning Python Level 1 - Sesión 13 Def Funtion (Deep)

## 13.1 Funciones Definidad en Python - Avanzado

### Profundizando en los parametros de las funciones

**LOS PARAMETROS**

Los `Parámetros` en Python son `variables` que se definen en la cabecera de una función y que reciben valores cuando se llama a la función estos valores se les denomina `Argumentos`. Los parámetros permiten que las funciones sean más `flexibles` y `reutilizables`, ya que pueden operar con diferentes datos en cada invocación. La `sintaxis` básica para definir una función con parámetros en Python es la siguiente:

```PYTHON
def nombre_de_la_funcion(parametro1, parametro2, ...):
    # bloque de código de la función que utiliza los parámetros
```
>parametro1, parametro2,… son los parámetros de la funcion

---

**LOS ARGUMENTOS**

 los `argumentos` son los `valores` reales pasados al llamarla<br>
**Ejemplo:**

```python
def saludar(nombre, mensaje): # parámetros
    print(f"{mensaje}, {nombre}")

saludar("Ana", "Hola") # argumentos
```

**EXPLICACIÓN DEL EJEMPLO:**

- `nombre` y `mensaje` son los **parámetros** de la función `saludar`.
- `"Ana"` y `"Hola"` son los **argumentos** que se pasan al llamar a la función.
- Cuando se ejecuta `saludar("Ana", "Hola")`, Python asigna `"Ana"` a `nombre` y `"Hola"` a `mensaje`.
---

<br>
<br>

# Tipos de parametros en funciones definidas

En Python, existen diferentes tipos de parámetros que permiten una mayor flexibilidad a la hora de definir funciones. Los tipos principales son:

## **1. Parámetros posicionales**

Son los más comunes y se pasan en el mismo orden en que se definen.

**Ejemplo 1:**

```python

def saludar(nombre, mensaje): # parámetros
    print(f"{mensaje}, {nombre}")

saludar("Ana", "Hola") # argumentos

```
**Ejemplo 2:**

```python
def suma(a, b):
    return a + b
suma(5, 3)  # a = 5, b = 3   
```
---

## **2. Parámetros predeterminados (`valor por defecto`)**

Se definen con un valor asignado en la definición. Si no se proporciona un argumento al llamar a la función, se usa el valor predeterminado.

**Ejemplo:**

```python
def saludar(nombre, mensaje="Hola"):
    print(f"{mensaje}, {nombre}")

saludar("Ana")  # Usa el valor predeterminado "Hola"
saludar("Ana", "Buen día")  # Sobrescribe el valor predeterminado
```
**NOTA IMPORTANTE**
>- Dentro de lo que son los parametros predeterminados o con valores por defecto,<br>
es importante mencionar que los parametros que tienen valores por defecto deben ir al final de la lista de parametros.

---
<br>

## **3. Parámetros con palabras clave (`keyword arguments`)**

Se pueden pasar los argumentos por nombre, lo que permite cambiar el orden de los parámetros.

**Ejemplo:**

```python
def saludar(nombre, mensaje):
    print(f"{mensaje}, {nombre}")

saludar(mensaje="Hola", nombre="Ana")  # Orden cambiado
```
---

## **4. Parámetros arbitrarios (`*args` y `**kwargs`)**

Permite pasar una cantidad variable de argumentos posicionales. A veces, cuando creas una `función`, no sabes cuántos datos te van a enviar. Imagina que eres un chef haciendo una pizza. Sabes que lleva masa y salsa, pero no sabes cuántos ingredientes extra pedirá el cliente.

### A. *args (`La lista de ingredientes`)

El asterisco * es mágico. Le dice a Python: "Toma todos los argumentos sobrantes que no tengan nombre y mételos en una tupla". Por convención le llamamos args, pero podrías llamarlo *ingredientes.

**Ejemplo:**

```python
def hacer_pizza(tamaño, *ingredientes):
    print(f"Preparando pizza {tamaño} con:")
    # Como 'ingredientes' es una tupla, podemos recorrerla
    for ingrediente in ingredientes:
        print(f"- {ingrediente}")

# Llamada con 1 extra
hacer_pizza("Grande", "Queso")
print("---")
# Llamada con 3 extras
hacer_pizza("Mediana", "Pepperoni", "Champiñones", "Pimientos")
```
>Lo que pasa bajo el capó: Python empaqueta "`Pepperoni`", "`Champiñones`", "`Pimientos"` en una tupla: `("Pepperoni", "Champiñones", "Pimientos")`.
---
<br>

### B **kwargs (Los detalles del pedido)**

El doble asterisco ** es para argumentos con nombre (KeyWord ARGuments). Python los empaqueta en un diccionario.

**Ejemplo:**

```python

def perfil_usuario(nombre, **datos_extra):
    print(f"Usuario: {nombre}")
    print("Información adicional:", datos_extra)

# Llamada normal
perfil_usuario("Ana")

# Llamada con datos variables
perfil_usuario("Carlos", edad=25, ciudad="Madrid", ocupacion="Estudiante")
```
>Lo que pasa bajo el capó: datos_extra se convierte en: `{'edad': 25, 'ciudad': 'Madrid', 'ocupacion': 'Estudiante'}`.

---
<br>

**Uso de `*` y `**` al llamar una función**

Cuando tenemos una lista o diccionario y queremos pasar sus elementos como argumentos a una función, podemos usar `*` y `**` respectivamente:

```python
def sumar(a, b, c):
    return a + b + c

valores = [1, 2, 3]
print(sumar(*valores))  # Resultado: 6
```
>Aquí:<br>
>- valores es una lista que contiene `[1, 2, 3]`<br>
>- Al llamar sumar(`*valores`), los elementos de la lista se desempaquetan y se pasan como argumentos a la función sumar
>- Es decir, es equivalente a llamar sumar`(1, 2, 3)`.

<br>

El operador `**` se utiliza de manera similar, pero para desempaquetar los elementos de un diccionario y pasarlos como argumentos a una función.<br>
En este caso, las claves del diccionario se convierten en nombres de parámetros y los valores del diccionario se asignan a esos parámetros.

```python
diccionario = {"a": 1, "b": 2, "c": 3}
print(sumar(**diccionario))  # Resultado: 6
```

> Aquí:<br>
>- diccionario es un diccionario que contiene {"a": 1, "b": 2, "c": 3}<br>
>- Al llamar sumar(**diccionario), los elementos del diccionario se desempaquetan y se pasan como argumentos a la función sumar,<br>
>- La clave "a" se asigna al parámetro a, la clave "b" se asigna a b y la clave "c" se asigna a c<br>
>- Es decir, es equivalente a llamar sumar(a=1, b=2, c=3)

---
<br>

## 5. **Paso por valor o por referencia**

En `Python`, el paso de argumentos a funciones se realiza siempre por valor (es decir, que la función siempre recibe una copia del argumento).

Pero el comportamiento será diferente si lo que pasamos es un tipo básico o una referencia.

>- En un tipo básico, la función invocada no podrá modificar el argumento que recibe
En un tipo referencia, sí podrá modificar el argumento que recibe.

Vamos a verlo con un ejemplo. Primero veamos el comportamiento cuando pasamos un tipo básico. Por ejemplo, pasamos número entero `(int)` a la función `modificar_numero()`.

Dentro de la función, multiplicamos el número por 2. Esta modificación no afecta al número original fuera de la función.

```python
# Ejemplo con un tipo básico (int)
def modificar_numero(numero):
    numero = numero * 2

numero_original = 5
modificar_numero(numero_original)
print("Número original después de llamar a la función:", numero_original)  # Resultado: 5.
```
<br>

Ahora veamos lo que pasa con un tipo referencia, por ejemplo una lista que pasamos como referencia a la función `modificar_lista()`.

Dentro de la función, añadimos el número 4 a la lista. La modificación realizada dentro de la función se refleja en la lista original fuera de la función.

```python
# Ejemplo con una referencia (lista)
def modificar_lista(lista):
    lista.append(4)

lista_original = [1, 2, 3]
modificar_lista(lista_original)
print("Lista original después de llamar a la función:", lista_original)  # Resultado: [1, 2, 3, 4]
```
